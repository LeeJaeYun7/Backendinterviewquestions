```

충돌 없는 복제 데이터 유형은 분산 데이터 저장 시스템 및 다중 사용자 응용 프로그램을 간소화하는 데이터 구조입니다.

많은 시스템에서 일부 데이터의 사본이 여러 컴퓨터에 저장되어야 합니다.
이러한 시스템의 예로는 다음이 있습니다.

로컬 기기에 데이터를 저장하고 해당 데이터를 동일한 사용자에 속한 다른 장치에 동기화해야 하는 모바일 앱(ex) 캘린더, 메모, 연락처 또는 알림)
데이터의 여러 복제본을 유지하는 분산 데이터베이스(동일한 데이터 센터 내 또는 다른 위치에 있음)로 일부 복제본이 오프라인 상태인 경우에도 시스템이 올바르게 작동함

Google 문서, Trello, Figma 또는 기타 다른 협업 소프트웨어로 여러 사용자가 동시에 동일한 파일이나 데이터를 수정할 수 있는 시스템
글로벌 확장성을 달성하기 위해 데이터를 복제하는 대규모 데이터 저장 및 처리 시스템
이러한 모든 시스템은 데이터가 여러 복제본에서 동시에 수정될 수 있다는 사실을 다루어야 합니다.
일반적으로 다음과 같이 데이터 수정을 다루는 두 가지 가능한 방법이 있습니다.

1) 강력한 일관성 복제
- 이 모델에서는 복제본이 수정 사항을 적용하는 시기와 방법을 결정하기 위해 서로 조정합니다.
-> 이 접근 방식은 직렬 가능한 트랜잭션 및 선형화 같은 강력한 일관성 모델을 가능하게 합니다.
-> 그러나 이 조정을 기다리는 것은 이러한 시스템의 성능을 감소시킵니다.
-> 또한 CAP 정리에 따르면 복제본이 시스템의 나머지 부분에서 연결이 끊어진 상태에서 데이터 변경을 할 수 없습니다.

2) 낙관적 복제
- 이 모델에서는 사용자가 복제본이 다른 복제본과 연결되어 있지 않거나 오프라인 상태인 경우에도
  데이터를 독립적으로 수정할 수 있습니다. 이 접근 방식은 최대 성능과 가용성을 제공하지만, 여러 클라이언트 또는
  사용자가 동시에 동일한 데이터를 수정할 때 충돌이 발생할 수 있습니다.
  이러한 충돌은 그 이후에 복제본이 서로 통신할 때 해결해아 합니다.

- 충돌 없는 복제 데이터 유형은 낙관적 복제를 사용하는 시스템에서 사용되며, 이러한 시스템에서 충돌 해결을 담당합니다.
  CRDT는 다른 복제본에서 어떤 데이터 수정이 이루어지든 항상 데이터를 일관된 상태로 병합할 수 있도록 보장합니다.
  이 병합은 CRDT가 자동으로 수행하며 특별한 충돌 해결 코드나 사용자 개입이 필요하지 않습니다. 


https://channel.io/ko/blog/crdt_vs_ot

CRDT와 OT


```
CRT와 OT란 동시편집 기술로, 실시간 협업 툴에 관련된 기술입니다.
-> 최근 코로나19로 재택근무하는 회사가 많아지면서 '실시간 협업 애플리케이션'도 주목되고 있는 것 같습니다.

(1) 실시간 협업 에디터가 동작되는 과정
-CRDT와 OT를 설명하기 전에, 실시간 협업 에디터가 어떻게 동작하는지 생각해봅시다
-> Google Docs에서 두 명의 사용자가 똑같이 "Hello!"를 보고 있다고 할 때,
   한 명은 Hello와 ! 사이에 World를 넣고, 다른 한 명은 ! 뒤에 :-) 이모티콘을 추가하겠죠.
   이렇게 되었을 때 결과가 어떻게 나와야 할까요?
-> 두 사용자가 입력한 값이 모두 합쳐져서, 'Hello World!:-)"가 나와야 하겠죠
-> 이러한 실시간 에디터에 사용되는 알고리즘은 CRDT와 OT, 2가지가 있습니다. 

(2) CRDT와 OT 비교
- OT(Operational Transformation)는 2006년 정도까지 사용되었던 기술이라고 해요
- -> Google Docs, MS Office에서 OT 기술이 사용되었습니다.
- CRDT는 2006년 이후부터 현재까지 사용되고 있는 기술입니다
- 저희가 요즘 사용하고 있는 Figma도 있고, REdis, 국내 협업도구 Yorkie에서도 CRDT를 사용하고 있다고 해요

(3) OT의 작동 원리
- 실제 예를 들어서 OT 기술 먼저 설명을 드리겠습니다
- 아까처럼 google docs에 두 명의 사용자가 같이 편집한다고 했을 때, 한 명은 helo 사이에 l을 추가하고,
  다른 한 명은 마지막에 !를 추가할 수 있겠죠
- 이 때, 변경사항은 인덱스 위치를 이용해서 L을 position 3에 넣는 오퍼레이션(왼쪽)과
  !를 position 4에 넣는 오퍼레이션(오른쪽)이 발생하게 됩니다.

- 이 두 개의 오퍼레이션을 서버로 보내게 되고, 이를 서버가 받아서 통합합니다.
-> l을 position 3에 먼저 넣게 될 경우, 원래는 !가 position 4에 들어가야 하는데 이미 l이 3에 들어가서
  위치가 바뀌어 버렸습니다.
-> 따라서, 인덱스 위치가 바뀌어 !를 4가 아닌 5에 넣게 됩니다
-> 이렇게 오퍼레이션이 이전 동작에 의해 바뀌어 다음 동작을 transform(변환) 시켜줘야 합니다
-> 이것이 바로 operation transformation OT 기술입니다.
-> 다시 정리하자면, 모든 변경사항 기록 -> 서버에 쭉 전송 -> 순차적 실행 -> 클라이언트에게 주는 방식이 됩니다.

(4) OT 방식의 문제점
-이러한 동작으로 인해 OT에는 단점이 있는데요, 유저가 서버에 수정사항을 던지게 되면 다른 유저들과 
 직접적으로 연동할 방법이 없습니다.
-> transformation을 하는 주체인 서버가 있어야 하기 때문이죠
-> 따라서 OT의 문제는 중앙 집중식 서버/DB가 필요하다는 것입니다
-> 이런 구조에서는 사람이 몰릴 때 과부하가 올 수 있습니다. 
-> 하지만 CRDT는 중앙집중식 서버가 필요하지 않습니다.
-> 어떤 네트워크, 통신을 선택하든지 제한이 없죠
-> 그래서 협업 애플리케이션 뿐 아니라, Redis Enterprise 같은 데이터 센터 간에 지역적으로 떨어져서
   운영하는 DB 시스템에도 활용된다고 합니다. 

(5) CRDT의 작동 원리
-CRDT의 정의는 '어떤 변경사항을 받으면, 순서와 상관없이 변경사항만 같으면 같은 상태'입니다.
-> OT는 순서가 중요하고, CRDT는 순서가 상관 없고, operation만 같으면 어긋나더라도 같은 상태가 됩니다.   
   
