


```


2.3.1절에서 분할 정복 체계의 한 가지 예로 병합 정렬이 동작하는 방법을 보았다
-> 분할 정복에서는 각 재귀 호출 레벨 위에서 다음 세 가지 단계를 거치면서 재귀적으로 문제를 푼다.

분할: 현재의 문제와 동일하되 입력의 크기가 더 작은 다수의 부분 문제로 분할한다
정복: 부분 문제를 재귀적으로 풀어서 정복한다. 부분 문제의 크기가 충분히 작으면 직접적인 방법으로 푼다.
결합: 부분 문제의 해를 결합해 원래 문제의 해가 되도록 만든다.

- 부분 문제가 재귀적으로 풀 수 있을 만큼 충분히 클 때 재귀 대상이라고 한다.
-> 부분 문제가 충분히 작아져 더 이상 재귀 호출을 할 수 없을 때, 재귀가 "바닥을 쳤다"고 하고,
   베이스 케이스까지 내려왔다고 이야기한다.
-> 때로는 입력의 크기가 더 작은 완전히 동일한 부분 문제 외에 원래의 문제와 다른 부분 문제를 풀어야 할 때도 있다
-> 그런 부분 문제는 결합 단계의 일부로 간주한다.

- 이 장에서는 더 많은 분할정복 기반의 알고리즘을 살펴볼 것이다
-> 첫 번째 알고리즘은 최대 부분 배열 문제(maximum-subarray problem)를 푸는 알고리즘이다.
-> 최대 부분 배열 문제는 배열을 입력으로 받아 가장 큰 합을 가지는 연속 부분 배열을 찾는 문제다.

- 다음으로는 nxn 행렬을 곱하는 두 가지 분할정복 알고리즘을 살펴볼 것이다
-> 하나는 O(n3)시간에 수행되는데, 정사각 행렬을 곱하는 일반적인 방법보다 나을 것이 없다
-> 그러나 다른 하나인 스트라센 알고리즘은 O(n2.81) 시간에 수행되며 이는 일반적인 방법보다 점근적으로 더 낫다.

2) 점화식
- 점화식은 분할정복 체계와 관련이 많다.
-> 점화식을 통해 분할정복 알고리즘의 수행시간을 자연스럽게 표현할 수 있기 때문이다.
-> 점화식은 더 작은 입력에 대한 자신의 값으로 함수를 나타내는 방정식 또는 부등식이다.
-> 예를 들어 2.3.2절에서 MERGE-SORT 프로시저의 최악의 경우 수행 시간 T(n)이 다음 점화식으로 표현될 수 있음을 보았다.

T(n) = O(1) if n = 1
       2T(n/2) + O(n) if n >= 1

- 이 점화식의 해는 T(n) = O(nlgn)이다.
-> 점화식은 여러 형태가 될 수 있다. 예를 들어, 어떤 재귀 알고리즘은 부분 문제를 2/3와 1/3 분할처럼
   비균등하게 나눌 수도 있다
-> 분할과 결합 단계에 선형 시간이 걸린다면 이 알고리즘에서 점화식 T(n) = T(2n/3) + T(n/3) + O(n)을 이끌어 낼 수 있을 것이다.


```
