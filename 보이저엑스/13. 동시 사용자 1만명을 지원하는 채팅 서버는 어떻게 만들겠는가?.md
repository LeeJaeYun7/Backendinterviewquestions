

```

이번 장에서는 채팅 시스템을 설계해 볼 것이다
채팅 시스템 하나쯤 사용하지 않는 사람은 드물다
그림 12-1에 현재 시장에서 가장 널리 쓰이고 있는 채팅 시스템을 몇 가지 나열해 보았다

채팅 앱이라고 했을 때, 사람들이 떠올리는 것은 제각각이다.
그러니 요구사항을 확실하게 해 두는 것이 아주 중요하다.
예를 들어, 면접관이 생각하고 있는 게 일대일 채팅 앱일 때 그룹 채팅 앱을 설계하면 곤란할 것이다.
기능 요구사항을 확실히 알아두도록 하자.

1단계) 문제 이해 및 설계 범위 확정
- 어떤 채팅 앱을 설계하려는지 확실히 해 두는 것이 면접에서 가장 중요하다.
  현재 시장에 나와 있는 앱들을 보면 페이스북 메신저, 위챗, 왓츠앱처럼 1:1 채팅에 집중하는 앱들이 있는 가 하면
  슬랙(Slack) 같은 그룹 채팅에 중점을 둔 업무용 앱이나, 게임 채팅에 쓰이는 디스코드(Discord)같이
  대규모 그룹의 소통과 응답지연(latency)이 낮은 음성 채팅에 집중하는 앱도 있다.

- 따라서 초반에 던져야 하는 질문들은 면접관이 원하는 앱이 정확히 무엇인지 알아내기 위한 것이어야 한다.
  적어도 설계 대상이 1:1 채팅 앱인지 아니면 그룹 채팅 앱인지 정도는 알아내야 한다.
  아래는 면접관이 던져볼 수 있는 질문의 사례다

지원자: 어떤 앱을 설계해야 하나요? 1:1 채팅 앱입니까 아니면 그룹 채팅 앱입니까?
면접관: 둘 다 지원할 수 있어야 합니다.
지원자: 모바일 앱인가요 아니면 웹 앱인가요?
면접관: 둘 다 입니다.
지원자: 처리해야 하는 트래픽 규모는 어느 정도입니까?
면접관: 일별 능동 사용자 수 기준으로 5천만명을 처리할 수 있어야 합니다.
지원자: 그룹 채팅의 경우에 인원 제한이 있습니까?
면접관: 최대 100명까지 참가할 수 있습니다.
지원자: 중요 기능으로 어떤 것이 있을까요? 가령, 첨부파일도 지원할 수 있어야 하나요?
면접관: 1:1 채팅, 그룹 채팅, 사용자 접속상태 표시를 지원해야 합니다.
       텍스트 메시지만 주고받을 수 있습니다.
지원자: 메시지 길이에 제한이 있나요?
면접관: 네, 100,000자 이하여야 합니다.
지원자: 종단 간 암호화(end-to-end encryption)을 지원해야 하나요?
면접관: 현재로서는 필요 없습니다만, 시간이 허락하면 논의해볼 수 있겠습니다.
지원자: 채팅 이력은 얼마나 오래 보관해야 할까요?
면접관: 영원히요.

이번 장에서 우리는 페이스북 메신저와 유사한 채팅 앱을 설계해볼 것이다.
이 앱은 다음과 같은 기능을 갖는다.

- 응답지연이 낮은 일대일 채팅 기능
- 최대 100명까지 참여할 수 있는 그룹 채팅 기능
- 사용자의 접속상태 표시 기능
- 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림

- 그리고 위의 질의응답 사례에 나온 대로, 5천만 DAU를 처리할 수 있도록 할 것이다.


2단계) 개략적 설계안 제시 및 동의 구하기

- 이 문제에 대한 훌륭한 답을 내기 위해서는 클라이언트와 서버의 통신 방법에 대한 기본적 지식은 갖추고 있어야만 한다.
  채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애플리케이션이다.
  클라이언트는 서로 직접 통신하지 않는다.
  대신, 각 클라이언트는 위에 나열한 모든 기능을 지원하는 채팅 서비스와 통신한다.
  우선은 기본 기능에 집중하도록 하자. 이 채팅 서비스는 아래 기능을 제공해야 한다.

- 클라이언트들로부터 메시지 수신
- 메시지 수신자(recipient) 결정 및 전달
- 수신자가 접속(online) 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

- 그림 12-2에 클라이언트(메시지 송신 클라이언트와 수신 클라이언트)와 채팅 서비스 사이의 관계를 요약해 보았다
-> 채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속한다
-> 따라서 채팅 서비스의 경우 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제다
   면접관과 상의하도록 하자

- 대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트인데, 채팅 시스템의 경우도 마찬가지다.
  메시지 송신 클라이언트(sender)가 이 역할을 한다.
  그림 12-2에서 송신 클라이언트는 수신 클라이언트에게 전달할 메시지를 채팅 서비스에 보낼 때,
  오랜 세월 검증된 HTTP 프로토콜을 사용한다.
  HTTP는 현재 웹에서 가장 널리 사용되는 프로토콜이다.
  이 그림에서 클라이언트는 채팅 서비스에 HTTP 프로토콜로 연결한 다음 메시지를 보내어 수신자에게 해당 메시지를 전달하라고 알린다.
  채팅 서비스와의 접속에는 keep-alive 헤더를 사용하면 효율적인데, 클라이언트와 서버 사이의 연결을 끊지 않고 계쏙 유지할 수 있어서다.
  TCP 접속 과정에서 발생하는 핸드셰이크 횟수를 줄일 수 있음은 물론이다.
  HTTP는 메시지 전송 용도로는 괜찮은 선택이며, 페이스북 같은 많은 대중적 채팅 프로그램이 초기에 HTTP를 사용했다.

- 하지만 메시지 수신 시나리오는 이것보다 복잡하다.
  HTTP는 클라이언트가 연결을 만드는 프로토콜이며, 서버에서 클라이언트로 임의 시점에 미시지를 보내는 데는 쉽게 쓰일 수 없다.
  서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해 많은 기법이 제안되어 왔는데,
  폴링(polling), 롱 폴링(long polling), 웹소켓(WebSocket) 등이 그런 기술이다.
  이들은 시스템 설계 면접에서 폭넓게 사용되는 중요한 기술이므로 그 각각을 좀 더 자세히 살펴보겠다.

(1) 폴링
- 그림 12-3에 제시한 대로, 폴링은 클라이언트가 주기적으로 서버에게 새 메시지가 있느냐고 물어보는 방법이다.
  폴링 비용은 폴링을 자주하면 할수록 올라간다.
  답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다는 문제도 있다.

(2) 롱 폴링
- 폴링은 여러 가지로 비효율적일 수 있어서 나온 기법이 롱 폴링(long polling)이다.
  롱 폴링의 경우 클라이언트는 새 메시지가 반환됙더나 타임아웃 될 때까지 연결을 유지한다.
  클라이언트는 새 메시지를 받으면 기존 연결을 종료하고, 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.
  이 방법에는 다음과 같은 약점이 있다.

- 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있다.
  HTTP 서버들은 보통 무상태(Stateless) 서버다.
  로드밸런싱을 위해 라운드 로빈(round robin) 알고리즘을 사용하는 경우,
  메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있는 것이다.

- 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다.

- 여전히 비효율적이다. 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속할 것이다.

(3) 웹소켓

```
