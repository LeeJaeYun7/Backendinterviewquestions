


```

[이펙티브 자바]

-스레드는 여러 활동을 동시에 수행할 수 있게 해준다. 하지만 동시성 프로그래밍은 단일 스레드 프로그래밍보다 어렵다.
-> 잘못될 수 있는 일이 늘어나고, 문제를 재현하기도 어려워지기 때문이다.
-> 그렇다고 동시성 프로그래밍으로부터 언제까지나 도망 다닐 수는 없다
-> 자바 플랫폼 자체에 내재되어 있을 뿐 아니라, 오늘날 어디서나 쓰이는 멀티코어 프로세서의 힘을 제대로 활용하려면
   반드시 내 것으로 만들어야만 하는 기술이기 때문이다.
-> 그래서 이번 장에는 동시성 프로그램을 정확하게 만들고 잘 문서화하는데 도움이 되는 조언들을 담았다.


[아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라]

- synchronized 키워드는 해당 메서드나 블록을 한 번에 한 스레드씩 수행하도록 보장한다.
-> 많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를
   다른 스레드가 보지 못하게 막는 용도로만 생각한다.
-> 먼저 이 관점에서 얘기해보자. 한 객체가 일관된 상태를 가지고 생성되고, 이 객체에 접근하는 메서드는 그 객체에
   락(lock)을 건다.
-> 락을 건 메서드는 객체의 상태를 확인하고 필요하면 수정한다.
-> 즉, 객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화시킨다.
-> 동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없을 것이다.

- 맞는 설명이지만, 동기화에는 중요한 기능이 하나 더 있다.
-> 똥기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.
-> 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된
   모든 이전 수정의 최종 결과를 보게 해준다.

- 언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.
-> 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장한다는 뜻이다.

- 이 말을 듣고 "성능을 높이려면 원자적 데이터를 읽고 쓸 때는 동기화하지 말아야겠다"고 생각하기 쉬운데, 아주 위험한 발상이다.
-> 자바 언어 명세는 스레드가 필드를 읽을 때, 항상 '수정이 완전히 반영된'값을 얻는다고 보장하지만,
   한 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다.
-> 동기화는 배타적 실행 뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
-> 이는 한 스레드가 만든 변화가 다른 스레드에게 언제 어떻게 보이는지를 규정한 자바의 메모리 모델 때문이다.



```
