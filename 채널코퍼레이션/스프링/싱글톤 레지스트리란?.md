```

토비의 스프링 p.105

-애플리케이션 컨텍스트는 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너다
-> 그러면서 동시에 이 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다

- 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다
-> 여기서 싱글톤이라는 것은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만, 그 구현 방법은 확연히 다르다


1) 서버 애플리케이션과 싱글톤
- 왜 스프링은 싱글톤으로 빈을 만드는 것일까? 이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는
  서버 환경이기 때문이다. 물론 스프링으로 PC 등에서 동작하는 독립형 윈도우 프로그램 같은 걸 개발할 수도 있긴 하지만
  실제로는 극히 드물다.
  태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버 환경에서 사용될 때 그 가치가 있다.
  실제로 스프링은 대부분 서버환경에서 사용된다.

- 스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩
  브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다
-> 또 하나의 요청을 처리하기 위해 데이터 액세스 로직, 서비스 로직, 비즈니스 로직, 프레젠테이션 로직 등의
   다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조로 이뤄진 경우가 대부분이다.
-> 비즈니스 로직도 복잡한 경우가 많다.

- 그런데 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 해보자.
  요청 한 번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면, 초당 2500개의 새로운 오브젝트가 생성된다
-> 1분이면 십오만 개, 한 시간이면 9백만 개의 새로운 오브젝트가 만들어진다
-> 아무리 자바의 오브젝트 생성과 가비지 컬렉션의 성능이 좋아졌다고 한들, 이렇게 부하가 걸리면 서버가 감당하기 힘들다

- 그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다
-> 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있다
-> 스펙에서 강제하진 않지만, 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다
-> 서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다

- 이렇게 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다
-> 따라서 서버환경에서는 서비스 싱글톤의 사용이 권장된다
-> 하지만 디자인 패턴에 소개된 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점이 있다
-> 그래서 심지어 이런 싱글톤 패턴을 피해야 할 패턴이라는 의미로 안티패턴이라고 부르는 사람도 있다


2) 싱글톤 패턴의 한계 
- 자바에서 싱글톤을 구현하는 방법은 보통 이렇다
(1) 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다
(2) 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다
(3) 스태틱 팩토리 메소드인 getInstance()를 만들고, 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다
-> 생성된 오브젝트는 스태틱 필드에 저장된다
-> 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다
(4) 한 번 오브젝트(싱글톤)가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔
    오브젝트를 넘겨준다.

- UserDao를 전형적인 싱글톤 패턴을 이용해 만든다면 리스트 1-22와 같이 될 것이다.

```
public class UserDao {
   private static UserDao INSTANCE;

   private UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker; 
   }

   public static synchronized UserDao getInstance(){
       if (INSTANCE == null) INSTANCE = new UserDao(???)
       return INSTANCE; 
   }
   
```

- 일단 깔끔하게 정리했던 UserDao에 싱글톤을 위한 코드가 추가되고 나니 코드가 상당히 지저분해졌다는 느낌이 든다
-> 게다가 private으로 바뀐 생성자는 외부에서 호출할 수가 없기 때문에 DaoFactory에서 UserDao를 생성하며
   ConnectionMaker 오브젝트를 넣어주는 게 이제는 불가능해졌다
-> 여러모로 생각해봐도 지금까지 깔끔하게 개선해온 UserDao에 싱글톤 패턴을 도입하는 건 무리로 보인다.

- 일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.
(1) private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 싱글톤 패턴은 생성자를 private으로 제한한다.
-> 오직 싱글톤 클래스 자신만이 자기 오브젝트를 만들도록 제한하는 것이다.
```
`` 
