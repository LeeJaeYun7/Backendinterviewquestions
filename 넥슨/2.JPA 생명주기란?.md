

```

1) 영속성 컨텍스트란?
- JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트다.
-> 우리말로 번역하기가 어렵지만 해석하자면 '엔티티를 영구 저장하는 환경'이라는 뜻이다.
-> 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

em.persist(member);

- 지금까지는 이 코드를 단순히 회원 엔티티를 저장한다고 표현했다.
-> 정확히 이야기하면 persist() 메소드는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다.

- 지금까지 영속성 컨텍스트를 직접 본 적은 없을 것이다.
-> 이것은 논리적인 개념에 가깝고 눈에 보이지도 않는다.
-> 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.
-> 그리고 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.


2) 엔티티의 생명주기
- 엔티티에는 4가지 상태가 존재한다.

(1) 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
(2) 영속: 영속성 컨텍스트에 저장된 상태
(3) 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
(4) 삭제: 삭제된 상태

(1) 비영속
- 엔티티 객체를 생성했다. 지금은 순수한 객체 상태이며 아직 저장하지 않았다.
  따라서 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.
-> 이것을 비영속 상태라 한다. 그림 3.3을 참고하자.

(2) 영속
- 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장했다.
-> 이렇게 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.
-> 이제 회원 엔티티는 비영속 상태에서 영속 상태가 되었다.
-> 결국 영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻이다.
-> 그림 3.4를 참고하자.
-> 그리고 em.find()나 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태다.

(3) 준영속
- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
-> 특정 엔티티를 준영속 상태로 만들려면 em.detach()를 호출하면 된다.
-> em.close()를 호출해서 영속성 컨텍스트를 닫거나 em.clear()를 호출해서 영속성 컨텍스트를 초기화해도
   영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다.

(4) 삭제
- 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.


3) 영속성 컨텍스트의 특징
- 영속성 컨텍스트의 특징은 다음과 같다.
(1) 영속성 컨텍스트와 식별자 값
- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
-> 따라서 영속 상태는 식별자 값이 반드시 있어야 한다
-> 식별자 값이 없으면 예외가 발생한다

(2) 영속성 컨텍스트와 데이터베이스 저장
- 영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까?
-> JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데,
   이것을 플러시(flush)라 한다.
-> 자세한 내용은 조금 뒤에 있는 플러시에서 알아보자.

(3) 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

- 지금부터 영속성 컨텍스트가 왜 필요하고, 어떤 이점이 있는지 엔티티를 CRUD 하면서 그 이유를 하나씩 알아보자.

3.1) 엔티티 조회
- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.
-> 영속 상태의 엔티티는 모두 이곳에 저장된다
-> 쉽게 이야기하면 영속성 컨텍스트 내부에 Map이 하나 있는데, 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스다.

// 엔티티를 생성한 상태(비영속)
Member member = new Member();
member.setId("memebr1");
member.setUsername("회원1");

// 엔티티를 영속
em.persist(member);

- 이 코드를 실행하면 그림 3.5처럼 1차 캐시에 회원 엔티티를 저장한다. 회원 엔티티는 아직 데이터베이스에 저장되지 않았다.
-> 1차 캐시의 키는 식별자 값이다. 그리고 식별자 값은 데이터베이스 기본 키와 매핑되어 있다.
-> 따라서 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.

- 이번에는 엔티티를 조회해보자.
Member member = em.find(Member.class, "member1");

- find() 메소드를 보면 첫 번째 파라미터는 엔티티 클래스의 타입이고, 두 번째는 조회할 엔티티의 식별값이다.

// EntityManager.find() 메소드 정의
public <T> T find(Class<T> entryClass, Object primaryKey);

- em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고, 만약 찾는 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회한다.

3.2) 1차 캐시에서 조회
- 그림 3.6을 보자. em.find()를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다.
-> 만약 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다.

- 다음 코드는 1차 캐시에 있는 엔티티를 조회한다.

Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

// 1차 캐시에 저장됨
em.persist(member);

// 1차 캐시에서 조회
Member findMember = em.find(Member.class, "member1");

3.3) 데이터베이스에서 조회
- 만약 em.find()를 호출했는데, 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다.
-> 그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.

Member findMember2 = em.find(Member.class, "member2");

- 그림 3.7을 분석해보자.
1. em.find(Member.class, "member2")를 실행한다.
2. member2가 1차 캐시에 없으므로 데이터베이스에서 조회한다.
3. 조회한 데이터로 member2 엔티티를 생성해서 1차 캐시에 저장한다.(영속 상태)
4. 조회한 엔티티를 반환한다.

- 이제 member1, member2 엔티티 인스턴스는 1차 캐시에 있다.
-> 따라서 이 엔티티들을 조회하면 메모리에 있는 1차 캐시에서 바로 불러온다.
-> 따라서 성능상 이점을 누릴 수 있다.

3.4) 영속 엔티티의 동일성 보장
- 다음 코드를 통해 식별자가 같은 엔티티 인스턴스를 조회해서 비교해보자.

Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // 동일성 비교

- 여기서 a == b는 참일까 거짓일까?

em.find(Member.class, "member1")를 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.
-> 따라서 둘은 같은 인스턴스고 결과는 당연히 참이다.
-> 따라서 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.

동일성과 동등성
- 동일성(identity): 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.
- 동등성(equality): 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. 자바에서 동등성 비교는 equals() 메소드를 구현해야 한다.

- JPA는 1차 캐시를 통해 반복 가능한 읽기(REPETABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 장점이 있다.
-> 트랜잭션 격리 수준은 16.1절에서 알아보겠다.

3.5) 엔티티 등록
- 엔티티 매니저를 사용해서 엔티티를 영속성 컨텍스트에 등록해보자. 예제 3.2를 보자.

EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 한다.
transaction.begin();

em.persist(memberA);
em.persist(memberB);
// 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.

// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction.commit(); // [트랜잭션] 커밋

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다.
-> 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.
-> 그림으로 분석해보자.



```
