


```

-많은 사람이 인덱스를 언급할 때는 항상 책의 맨 끝에 있는 찾아보기로 설명한다.
-> 책의 마지막에 있는 "찾아보기"가 인덱스에 비유된다면 책의 내용은 데이터 파일에 해당한다고 볼 수 있다.
-> 책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 것이다.

-DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.
-> 그래서 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value pair)으로 삼아
   인덱스를 만들어 두는 것이다.

- 그리고 책의 "찾아보기"와 DBMS 인덱스의 공통점 가운데 중요한 것이 바로 정렬이다.
-> 책의 찾아보기도 내용이 많아지면 우리가 원하는 검색어를 찾아내는 데 시간이 걸릴 것이다.
-> 그래서 최대한 빠르게 찾아갈 수 있게 "ㄱ", "ㄴ", "ㄷ", ... 과 같은 순서로 정렬돼 있는데,
   DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

- 인덱스의 또 다른 특성을 설명하고자 이번에는 프로그래밍 언어의 자료 구조로 인덱스와 데이터 파일을 비교해 가면서
  살펴보자.
-> 프로그래밍 언어별로 각 자료 구조의 이름이 조금씩 다르긴 하지만, SortedList와 ArrayList라는 자료 구조는 익숙할 정도로 많이 들어봤을 것이다.
-> SortedList는 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다.
-> SortedList는 저장되는 값을 항상 정렬된 상태로 유지하는 자료 구조이며, ArrayList는 값을 저장되는 순서 그대로 유지하는 자료 구조다.
-> DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지한다.
-> 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장해 둔다.

- 그러면 이제 SortedList의 장단점을 통해 인덱스의 장단점을 살펴보자.
-> SortedList 자료 구조는 데이터가 저장될때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만,
   이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다.
-> DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 INSERT나 UPDATE, DELETE 문장의 처리가 느려진다.
-> 하지만 이미 정렬된 "찾아보기"용 표(인덱스)를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리할 수 있다.

- 결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고, 그 대신 데이터의 읽기 속도를 높이는 기능이다.
-> 여기서도 알 수 있듯이 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지,
   읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.
-> SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고,
   인덱스의 크기가 비대해져, 오히려 역효과만 불러올 수 있다.

 




```
