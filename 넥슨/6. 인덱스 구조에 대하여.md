


```

-많은 사람이 인덱스를 언급할 때는 항상 책의 맨 끝에 있는 찾아보기로 설명한다.
-> 책의 마지막에 있는 "찾아보기"가 인덱스에 비유된다면 책의 내용은 데이터 파일에 해당한다고 볼 수 있다.
-> 책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 것이다.

-DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.
-> 그래서 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value pair)으로 삼아
   인덱스를 만들어 두는 것이다.

- 그리고 책의 "찾아보기"와 DBMS 인덱스의 공통점 가운데 중요한 것이 바로 정렬이다.
-> 책의 찾아보기도 내용이 많아지면 우리가 원하는 검색어를 찾아내는 데 시간이 걸릴 것이다.
-> 그래서 최대한 빠르게 찾아갈 수 있게 "ㄱ", "ㄴ", "ㄷ", ... 과 같은 순서로 정렬돼 있는데,
   DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

- 인덱스의 또 다른 특성을 설명하고자 이번에는 프로그래밍 언어의 자료 구조로 인덱스와 데이터 파일을 비교해 가면서
  살펴보자.
-> 프로그래밍 언어별로 각 자료 구조의 이름이 조금씩 다르긴 하지만, SortedList와 ArrayList라는 자료 구조는 익숙할 정도로 많이 들어봤을 것이다.
-> SortedList는 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다.
-> SortedList는 저장되는 값을 항상 정렬된 상태로 유지하는 자료 구조이며, ArrayList는 값을 저장되는 순서 그대로 유지하는 자료 구조다.
-> DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지한다.
-> 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장해 둔다.

- 그러면 이제 SortedList의 장단점을 통해 인덱스의 장단점을 살펴보자.
-> SortedList 자료 구조는 데이터가 저장될때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만,
   이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다.
-> DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 INSERT나 UPDATE, DELETE 문장의 처리가 느려진다.
-> 하지만 이미 정렬된 "찾아보기"용 표(인덱스)를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리할 수 있다.

- 결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고, 그 대신 데이터의 읽기 속도를 높이는 기능이다.
-> 여기서도 알 수 있듯이 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지,
   읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.
-> SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고,
   인덱스의 크기가 비대해져, 오히려 역효과만 불러올 수 있다.

- 인덱스는 데이터를 관리하는 방식(알고리즘)과 중복 값의 허용 여부 등에 따라 여러 가지로 나눠볼 수 있다.
-> 이 분류는 인덱스를 좀 더 효율적으로 설명하기 위해 저자가 임의로 분류한 것이다.
-> 이 책에서는 키(Key)라는 말과 인덱스(Index)는 같은 의미로 사용하겠다.
-> 인덱스를 역할별로 구분해 본다면 프라이머리 키(Primary key)와 보조 키(세컨더리 인덱스, Secondary Key)로 구분할 수 있다.

- 프라이머리 키는 이미 잘 아는 것처럼 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미한다.
-> 이 칼럼(때로는 칼럼의 조합)은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에,
   우리는 이를 식별자라고도 부른다.
-> 프라이머리 키는 NULL 값을 허용하지 않으며 중복을 허용하지 않는 것이 특징이다.

- 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스(Secondary Index)로 분류한다.
-> 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체 키라고도 하는데,
   별도로 분류하기도 하고 그냥 세컨더리 인덱스로 분류하기도 한다.

- 데이터 저장 방식(알고리즘)별로 구분할 경우 사실 상당히 많은 분류가 가능하겠지만,
  대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.
-> 물론 이 외에도 수많은 알고리즘이 있지만, 대표적으로 시중의 RDBMS에서 많이 사용하는 알고리즘은 이 정도일 것이다.

- B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘으로서, 상당히 오래전에 도입된 알고리즘이며,
  그만큼 성숙해진 상태다.
-> B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
-> MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.

- Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.
-> 하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.
-> Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

- 데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
-> 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만,
   실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제가 된다.

- 유니크 인덱스에 대해 동등 조건(Equal, =)로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
-> 그뿐만 아니라 유니크 인덱스로 인한 MySQL의 처리 방식의 변화나 차이점이 상당히 많다.
-> 이러한 부분은 인덱스와 쿼리의 실행 계획을 살펴보면서 배울 것이다.

- 인덱스의 기능별로 분류해보면 전문 검색용 인덱스나 공간 검색용 인덱스 등을 예로 들 수 있다.
-> 물론 이 밖에도 수없이 많은 인덱스가 있겠지만, MySQL을 사용할 때는 이 두 가지만으로도 충분하다.
-> 전문 검색이나 공간 검색용 인덱스는 뒤에서 좀 더 자세히 살펴보겠다.

3) B-Tree 인덱스
- B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘이다.
-> 하지만 아직도 가장 범용적인 목적으로 사용되는 인덱스 알고리즘이다.
-> B-Tree에는 여러 가지 변형된 형태의 알고리즘이 있는데, 일반적으로 DBMS에서는 주로 B+-Tree 또는 B*-Tree가 사용된다.
-> 인터넷사에서 쉽게 구할 수 있는 B-Tree의 구조를 설명한 그림 때문인지 많은 사람들이 B-Tree의 "B"가 바이너리(이진)트리라고 잘못 생각한다.
-> 하지만 B-Tree의 "B"는 "Binary(이진)"의 약자가 아니라 "Balanced"를 의미한다는 점에 주의하자.

- B-Tree는 칼럼의 원래 값을 변형시키지 않고(물론 값의 앞부분만 잘라서 관리하기는 하지만) 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
-> 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.

3-1) 구조 및 특성
- B-Tree 인덱스를 제대로 사용하려면 B-Tree의 기본적인 구조를 알아야 한다.
-> B-Tree는 트리 구조의 최상위에 하나의 "루트 노드(Root node)"가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태다.
-> 트리 구조의 가장 하위에 있는 노드를 "리프 노드"라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 "브랜치 노드"라고 한다.
-> 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
-> 그림 8.4는 B-Tree 인덱스의 각 노드와 데이터 파일의 관계를 표현한 것이다.

- 그림 8.4에서와 같이 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
-> 많은 사람들이 데이터 파일의 레코드는 INSERT된 순서대로 저장되는 것으로 생각하지만 그렇지 않다.
-> 만약 테이블의 레코드를 전혀 삭제하거나 변경하지 않고 INSERT만 수행한다면 맞을 수도 있다.
-> 하지만 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에
   항상 INSERT된 순서로 저장되는 것은 아니다.






```
