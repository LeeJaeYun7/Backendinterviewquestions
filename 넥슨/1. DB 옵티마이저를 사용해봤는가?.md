


```

- MySQL 서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양하다
-> 이런 다양한 방법 중에서 어떤 방법이 최적이고, 최소의 비용이 소모될지 결정해야 한다
-> 여행할 때도 인터넷이나 책 등을 참고해서 최소한의 비용이 드는 방법을 알아본 뒤에 여행 경로를 결정한다
-> MySQL에서도 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며,
   그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다.
-> MySQL 서버를 포함한 대부분의 DBMS에서는 옵티마이저가 이러한 기능을 담당한다.

- MySQL에서는 EXPLAIN이라는 명령으로 쿼리의 실행 계획을 확인할 수 있는데,
  EXPLAIN 명령의 결과에는 상당히 많은 정보가 출력된다.
-> 실행 계획에 표시되는 내용을 제대로 이해하려면 MySQL 서버 옵티마이저가 실행하는 최적화에 대해 어느 정도 지식을 갖추고 있어야 한다

- 이번 장에서는 MySQL 서버가 사용자의 요청을 처리하기 위해 데이터를 가공하는 기본 절차와 빠른 성능을 보장하기 위해 수행하는 최적화에
  대해 살펴보겠다.


1) 개요
- 어떤 DBMS라든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분으로 알려져 있으며,
  옵티마이저가 만들어 내는 실행 계획을 이해하는 것 또한 상당히 어려운 부분이다.
-> 하지만 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다
-> 실행 계획을 살펴보기 전에 먼저 알고 있어야 할 몇 가지 사항을 살펴보자.

1.1) 쿼리 실행 절차
- MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있느 수준으로 분리(파스 트리)한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고, 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

- 첫 번째 단계를 SQL 파싱이라고 하며, MySQL 서버의 "SQL 파서"라는 모듈로 처리한다.
-> SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다.
-> 또한 이 단계에서 "SQL 파스 트리"가 만들어진다.
-> MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.

- 두 번째 단계는 첫 번째 단계에서 만들어진 SQL 파스 트리를 참조하면서 다음과 같은 내용을 처리한다.
1. 불필요한 조건 제거 및 복잡한 연산의 단순화
2. 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
3. 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
4. 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정

- 물론 이 밖에도 수많은 처리를 하지만 대표적으로 이러한 작업을 들 수 있다.
-> 두 번째 단계는 "최적화 및 실행 계획 수립" 단계이며, MySQL 서버의 "옵티마이저"에서 처리한다.
-> 또한, 두 번째 단계가 완료되면 쿼리의 "실행 계획"이 만들어진다.
-> 세 번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고,
   MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.
-> 첫 번째 단계와 두 번째 단계는 거의 MySQL 엔진에서 처리하며, 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.


1.2) 옵티마이저의 종류
- 옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당한다
-> 옵티마이저는 현재 대부분의 DBMS가 선택하고 있는 비용 기반 최적화 방법과
   예전 초기 버전의 오라클 DBMS에서 많이 사용했던 규칙 기반 최적화 방법으로 크게 나눌 수 있다

(1) 규칙 기반 최적화는 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라
    실행 계획을 수립하는 방식을 의미합니다.
-> 이 방식에서는 통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않고 실행 계획으 수립되기 때문에
   같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어낸다.
-> 하지만 사용자의 데이터는 분포도가 매우 다양하기 때문에 규칙 기반의 최적화는 이미 오래전부터 많은 DBMS에서 거의 사용되지 않는다.

(2) 비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고,
    각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
-> 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.

- 규칙 기반 최적화는 각 테이블이나 인덱스의 통계 정보가 거의 없고, 상대적으로 느린 CPU 연산 탓에
  비용 계산 과정이 부담스럽다는 이유로 사용되던 최적화 방법이다.
-> 현재는 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있으며, MySQL 역시 마찬가지다.


2) 기본 데이터 처리
- MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다.
-> 하지만 결과물은 동일하더라도 RDBMS 별로 그 결과를 만들어내는 과정은 천차만별이다.
-> 여기서는 이러한 기본적인 가공을 위해 MySQL 서버가 어떤 알고리즘을 사용하는지 간단히 살펴보겠다.

2-1) 풀 테이블 스캔과 풀 인덱스 스캔
- 인덱스 처리에 대한 자세한 내용은 이미 8장 '인덱스'에서 살펴봤으므로,
  여기서는 풀 테이블 스캔에 대한 내용을 간단히 살펴보겠다.
-> 풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
-> MySQL 옵티마이저는 다음과 같은 조건이 일치할 때, 주로 풀 테이블 스캔을 선택한다.

(1) 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
(2) WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
(3) 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
    (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

- 일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다.
-> 그래서 대부분 DBMS는 풀 테이블 스캔을 실행할 때, 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.
-> 하지만 MySQL에는 풀 테이블 스캔을 실행할 때, 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수는 없다.
-> 그래서 많은 사람들이 MySQL은 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어 오는 것으로 생각한다.

- 이것은 MyISAM 스토리지 엔진에는 맞는 이야기지만 InnoDB에서는 틀린 말이다
-> InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
-> 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을
   의미한다.
-> 즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만,
   특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
-> 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킨다.
-> 이 때, 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둔다.
-> 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리되는 것이다.

- MySQL 서버에서는 innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.
-> 포그라운드 스레드에 의해 innodb_reac_ahead_threshold 시스템 변수에 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 InnoDB 스토리지 엔진은
   백그라운드 스레드를 이용해 대량으로 그 다음 페이지들을 읽어서 버퍼 풀로 적재한다.
-> 일반적으로 디폴트 설정으로도 충분하지만 데이터 웨어하우스용으로 MySQL을 사용한다면 이 옵션을 더 낮은 값으로 설정해서,
   더 빨리 리드 어헤드가 시작되게 유도하는 것도 좋은 방법이다.

- 리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다.
-> 풀 테이블 스캔이 테이블을 처음부터 끝까지 스캔하는 것을 의미하듯이,
   풀 인덱스 스캔은 인덱스를 처음부터 끝까지 스캔하는 것을 의미한다.
-> 예를 들어, 다음과 같은 쿼리를 한 번 생각해보자.




```
