

```

1)SRP
- 어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다
그림 5-1과 같이 남자라고 하는 클래스와 남자 클래스에 의존하는 다양한 클래스가 있다고 하자.
딱 봐도 남자는 참 피곤할것 같다. 이러한 피곤함은 역할과 책임이 너무 많기 때문이다. 객체지향의 세계에서는 이런 경우 나쁜 냄새가 난다고 한다. 예를 들어, 어느 날 여자친구와 헤어졌다고 해보자.
남자는 더 이상 챙길 일 없는 기념일과 대상이 없는 키스하기에 힘들어하게 된다. 거기에 더해 여자 친구 없는 스트레스를 온 세상에 뿌리고 다니니 어머니, 직장 상사, 소대장님까지 피곤한 지경에 이르게 되고야 만다.

따라서 이런 경우에 역할(책임)을 분리하라는것이 단일 책임 원칙이다. 그림 5-1의 클래스 설계를 그림 5-2처럼 바꿔보자.

남자라는 하나의 클래스가 역할과 책임에 따라 네 개의 클래스로 쪼개진 것을 볼 수 있다. 그리고 역할과 클래스명도 딱 떨어지니 이해하기도 좋다.
이제 여자 친구와 이별하더라도 남자 친구만 상처를 입으면 된다. 어머니-아들 관계, 직장 상사-사원 관계, 소대장-소대원 관계는 여자 친구와 이별한 남자친구로부터 어떠한 영향도 받지 않는 아름다운 세상이 온 것이다.
어떤가? 아까 하나의 클래스에 다수의 역할과 책임이 몰려 있을때는 냄새가 나더니, 클래스를 역할과 책임에 따라 분리해서 각각 하나의 역할과 책임만 갖게 하니 향기가 나게 되지 않는가?
여기서는 클래스의 분할에 대해서만 이야기했지만, 단일 책임 원칙은 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있는 개념이다.


2)OCP
- "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만, 변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴

- 위 문장을 조금 더 의역해 보면 아래와 같은 문장을 이끌어낼 수 있다.
"자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다"

- 개방 폐쇄 원칙은 다양한 곳에서 다양하게 이야기되고 있으니 딱 꼬집어서 예를 들기가 쉽지는 않다
-> 조금 억지스럽지만 몇 가지 예제를 통해 개방 폐쇄 원칙을 이해해보자.

- 어느 날 한 운전자가 마티즈를 구입했다. 그리고 열심히 마티즈에 적응했다고 해보자
-> 그리고 훗날 그 운전자에게 쏘나타가 생겼다.

- 그림 5-4처럼 창문과 기어가 수동이던 마티즈에서 그림 5-5처럼 창문과 기어가 자동인 쏘나타로 차종을 바꾸니 운전자의 행동에도 변화가 온다
-> 마티즈를 운전할 때, 운전자는 마티즈 인스턴스의 기어수동조작() 메서드를 사용했는데, 쏘나타로 차종을 변경하자 쏘나타 인스턴스의 기어자동조작() 메서드를 사용하게 된다
-> 운전자는 차량에 따라 운전하던 습관을 바꿔야만 하는 것일까?

- 스틱 차량에서 오토 차량으로 바꿨다고 해서 운전자가 운정네 영향을 받아야만 하는가를 생각해보자.
-> 현실 세계라면 당연히 어느 정도 변화가 있어야 하겠지만, 객체 지향 세계에는 다른 해법이 있다.

- 그림 5-6과 같이 상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도, 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다
-> 다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에는 개방돼 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.

- 혹시라도 데이터베이스 프로그래밍을 경험한 적이 있다면 개방 폐쇄 원칙의 아주 좋은 예를 이미 알고 있을 것이다.
-> 그 예란 바로 JDBC다.
-> JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없다.
-> Connection 설정 부분을 별도의 설정 파일로 분리해두면 클라이언트 코드는 단 한 줄도 변경할 필요가 없다.
-> JDBC뿐만 아니라 iBatis, MyBatis, 하이버네이트 등등 데이터베이스 프로그래밍을 지원하는 라이브러리와 프레임워크에서도 개방 폐쇄 원칙의 예를 볼 수 있다.

- 그림 5-7을 보자. 오라클을 MySQL이나 MS-SQL로 교체할 때 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충 장치로 인해 변화에 영향을 받지 않는다
-> 바로 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀 있는 것이다.
-> 데이터베이스를 교체한다는 것은 데이터베이스가 자신의 확장에는 열려 있다는 것이다.

- 자바에도 개방 폐쇄 원칙이 적용돼 있다.
-> 자바 개발자는 작성하고 있는 소스코드가 윈도우에서 구동될지, 리눅스에서 구동될지 또는 또 다른 운영체제 상에서 구동될지에 대해서는
   걱정하지 않는다.
-> 각 운영체제별 JVM과 목적 파일(.class)가 있기에 개발자는 다양한 구동 환경에 대해서는 걱정하지 않고 본인이 작업하고 있는 개발 PC에 설치된 JVM에서
   구동되는 코드만 작성하면 된다.
-> 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제별 JVM은 확장에 열려 있는 구조가 되는 것이다.
-> 개발자의 소스코드와 운영체제별 JVM 사이에는 목적 파일이라고 하는 완충 장치가 있는 것이다.


3) 리스코프 치환 원칙
- "서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다" - 로버트 마틴

- 상속에 대해 설명하면서 객체지향에서의 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다고 했다.
-> 객체 지향의 상속은 다음의 조건을 만족해야 한다.

(1) 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다
(2) 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.

- 위 두 개의 문장대로 구현된 프로그램이라면 이미 리스코프 치환 원칙을 잘 키키고 있다고 할 수 있다.
-> 하지만 위 문장대로 구현되지 않으 코드가 존재할 수 있는데 바로 상속이 조직도나 계층도 형태로 구축된 경우다.

- 아버지를 상위 클래스(기반 타입)로 하는 딸이라는 하위 클래스(서브 타입)가 있다고 하자.
-> 바로 전형적인 계층도 형태이며, 객체 지향의 상속을 잘못 적용한 예다.
-> 그럼 무엇이 문제인지 생각해 보자.
-> 상위 클래스의 객체 참조 변수에는 하위 클래스의 인스턴스를 할당할 수 있다.

아버지 춘향이 = new 딸()

- 딱 봐도 이상하지 않은가? 딸을 하나 낳아서 이름을 춘향이라 한 거 까지는 좋은데 아빠의 역할을 맡기고 있다.
-> 춘향이는 아버지형 객체 참조 변수이기에 아버지 객체가 가진 행위(메서드)를 할 수 있어야 하는데
   춘향이에게 아버지의 어떤 역할을 시킬 수 있을까?
-> 이번에는 동물 클래스와 이를 상속(확장)하는 펭귄 클래스가 있다고 해보자.
-> 즉, 분류도 형태인 경우를 살펴보자.

동물 뽀로로 = new 펭귄()

- 논리적인 흠이 없다. 펭귄 한 마리가 태어나 뽀로로라 이름을 짓고 동물의 행위(메서드)를 하게 하는데 전혀 이상함이 없다.
-> 아버지-딸 구조(계층도/조직도)는 리스코프 치환 원칙을 위배하고 있는 것이며, 동물-펭귄 구조(분류도)는 리스코프 치환 원칙을 만족하는 것이다.
-> 로버트 C.마틴의 말을 다시 의역하고 결론을 내보자.

"하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다."

- 리스코프 치환 원칙은 말로 기억하기보다는 그림을 통해 기억하는 것이 편하다.
-> 리스코프 치환 원칙을 지키지 않는 경우는 그림 5-10의 계층도/조직도에서 볼 수 있다.

- 그림 5-10처럼 계층도/조직도이 ㄴ경우를 보면 딸이 아버지, 할아버지의 역할을 하는 것이 논리에 맞지 않음을 알 수 있다.
-> 리스코프 치환 원칙을 완벽하게 지원하는 경우는 그림 5-11의 분류도에서 볼 수 있다.

- 그림 5-11처럼 분류도인 경우 하위에 존재하는 것들은 상위에 있는 것들의 역할을 하는데 전혀 문제가 없다.
-> 고래가 포유류 또는 동물의 역할을 하는 것은 전혀 문제가 되지 않는다
-> 기억력이 좋은 독자라면 그림 5-10과 그림 5-11은 이미 3장에서 상속을 설명할 때 본 그림이라는 것을 기억할 것이다.
-> 결국 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다.
-> 객체 지향에서 가장 강력한 특성이라고 하는 상속이 잘못 적용됐을 때, 발생하는 문제점은 3장의 내용을 다시 한 번 참고하자.


4) ISP

```
