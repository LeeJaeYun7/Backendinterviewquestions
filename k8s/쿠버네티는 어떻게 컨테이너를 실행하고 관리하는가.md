


```
p.50

-쿠버네티스는 컨테이너로 애플리케이션을 실행하지만, 우리는 컨테이너를 직접 다루지 않는다.
-> 모든 컨테이너는 파드(pod)에 속하는데, 파드란 쿠버네티스가 하나 또는 그 이상의 컨테이너를 관리하는데 사용하는 단위다

- 또한 파드는 다른 리소스가 관리하고, 이런 고수준 리소스는 컨테이너의 세부 사항을 추상화시킨다.
-> 이 방법으로 자기수복형 애플리케이션이나 '바람직한 상태'워크플로가 가능해진다.
-> 쿠버네티스에 우리가 원하는 애플리케이션의 상태를 지시하면 이 상태를 실제로 만들어 내는 것이다.

- 이 장에서 쿠버네티스의 기본 단위이자 컨테이너를 실제 실행하는 역할을 담당하는 리소스인 파드와 파드의 관리를 담당하는
  디플로이먼트를 알아보자.
-> 간단한 웹 애플리케이션을 소재로 실습을 진행하며, 쿠버네티스 명령형 도구와 YAML 정의 파일을 사용하여 애플리케이션을 정의하고 관리해볼 것이다.




- 컨테이너는 일반적으로 애플리케이션 구성 요소 하나를 실행하는 가상화된 환경을 가리킨다.
-> 쿠버네티스는 이 컨테이너를 또 다른 가상 환경인 파드로 감싼다.
-> 파드는 컴퓨팅의 단위로, 클러스터를 이루는 노드 중 하나에서 실행된다.
-> 파드는 쿠버네티스로 관리되는 자신만의 가상 IP 주소를 가지며, 이 주소로 가상 네트워크에 접속된 다른 파드, 심지어 다른 노드에서 실행되는 파드라도 통신을 주고 받을 수 있다

- 파드 하나는 대개 컨테이너 하나를 포함하는데, 설정에 따라 파드 하나가 여러 개의 컨테이너를 포함할 수도 있다.
-> 파드에 포함된 모든 컨테이너는 같은 가상 환경에 포함된다.
-> 따라서 네트워크를 공유하며 localhost로 서로 통신할 수도 있다.
-> 그림 2-1은 컨테이너와 파드의 관계를 나타낸 다이어그램이다.

- 여러 개의 컨테이너를 포함하는 파드를 설명하기에는 조금 이를지도 모르지만, 파드가 여러 개의 컨테이너를 포함할 수 있다고 설명하고는
  단일 클러스터 파드만 설명하면 당연히 왜 그냥 컨테이너를 직접 다루지 않고 파드를 거치도록 했는지 궁금할 것이다.
-> 파드를 직접 실행해 보고 추상화된 컨테이너가 어떤 것인지 한 번 살펴보자.

- 그림 2-2는 마지막 줄의 describe pod 명령으로 출력된 내용 중 일부를 발췌한 것이다.
-> 독자 여러분의 환경에서는 Node-Selector나 Toleration 같은 훨씬 복잡한 내용이 먼저 눈에 들어올 것이다.
-> 이런 정보 역시 파드의 상세 정보 중 일부로, 우리가 run 명령에서 따로 지정하지 않았기 때문에 쿠버네티스에 있는 기본값이 적용된 것이다.

- 이제 클러스터에서 하나의 컨테이너를 실행했다.
-> 그리고 이 컨테이너는 파드 안에 들어 있는 상태다
-> 도커를 사용해 보았다면 익숙한 과정이었을 것이다
-> 또한 파드도 그렇게 어렵게 느껴지지 않는다.
-> 대부분의 파드는 하나의 컨테이너만 실행한다. 따라서 파드를 '쿠버네티스가 컨테이너를 실행하는 수단'으로 생각해도 크게 틀리지 않다.

- 쿠버네티스가 직접 컨테이너를 실행하지는 않는다.
-> 컨테이너를 생성할 책임을 해당 노드에 설치된 컨테이너 런타임에 맡기는 형태다.
-> 이 컨테이너 런타임은 도커가 될 수도 있고, 그 외에 더 특이한 것이 될 수도 있다.
-> 파드가 컨테이너를 추상화시킨 것인 이유가 여기에 있다

- 파드는 쿠버네티스가 관리하는 리소스고, 컨테이너는 쿠버네티스 외부에서 관리된다.
-> kubectl을 사용하여 파드에서 다음 정보를 확인해 보면 이를 쉽게 이해할 수 있다.

-필자의 환경에서 출력된 결과를 그림 2-3에 실었다. 필자는 윈도우용 도커 데스크톱에서 실행한 단일 노드 쿠버네티스 클러스터를 구동 중이다.
-> 두 번째 명령에서 출력된 NODE_IP는 필자의 리눅스 가상 머신의 IP 주소고, POD IP는 클러스터 속 파드의 가상 IP 주소다.
-> 세 번째 명령에서 출력된 컨테이너 식별자 앞에는 해당 컨테이너를 실행 중인 컨테이너 런타임의 이름이 붙는다.
-> 도커가 실행된 컨테이너이므로 docker가 붙었다.

- 실습이 조금 지루했을지도 모르겠다.
-> 하지만 여기에서 기억해야 할 점이 두가지 있다.
-> 첫 번째는 kubectl이 매우 강력한 도구라는 점이다.
-> 쿠버네티스와의 주요 접점 역할 외에도 다양한 용도로 kubectl을 사용하게 될 것이다.
-> kubectl의 기능을 확실히 파악해 두면 도움이 된다.
-> 명령어에 관심 있는 출력 내용에 대한 질의를 지정하는 것도 유용하다.
-> 리소스 정보 중 원하는 정보에 마음대로 접근할 수 있고, 특히 자동화시킬 때 편리하다.
-> 두 번째는 컨테이너를 직접 실행하는 것은 쿠버네티스가 아니라는 점이다.
-> 파드에서 볼 수 있는 컨테이너 식별자는 컨테이너가 실제 실행되는 다른 시스템을 가리키는 참조일 뿐이다.

- 파드는 파드를 생성할 때 한 노드에 배정된다.
-> 그리고 이 파드를 관리하고 파드에 포함된 컨테이너를 실행하는 책임도 이 노드가 맡는다.
-> 이 과정은 컨테이너 런타임 인터페이스(CRI)라는 공통 API를 이용하여 컨테이너 런타임과 연동되는 형태로 진행된다.
-> CRI를 사용하면 해당 노드가 어떤 컨테이너 런타임을 실행 중이더라도 같은 방식으로 노드를 관리할 수 있다.
-> 컨테이너 생성과 삭제, 컨테이너 정보 확인 기능이 표준 API로 제공된다.
-> 파드 실행 중에는 노드가 컨테이너 런타임과 연동하며, 파드에 필요한 모든 컨테이너가 갖추어져 있는지 확인한다. 
```
