

- 2장 두 번째 절인데 벌써 두 번째 쿠버네티스 객체, 컨트롤러 객체를 배우게 되었다
-> 컨트롤러 객체는 다른 객체를 다시 추상화한 것이다
-> 쿠버네티스가 매우 복잡한 시스템이기는 하지만, 이 복잡성이 바로 강력하고 다양한 설정이 가능한 시스템을 만드는 원동력이다.
-> 학습에 따르는 약간의 어려움은 전 세계적으로 널리 쓰이는 컨테이너 플랫폼에 참여할 수 있는 입장료라고 생각하자

- 파드는 직접 사용하기에는 너무 단순한 객체다
- -> 파드는 고립된 한 벌의 애플리케이션이며, 각 파드는 서로 다른 노드에 배정된다
- -> 어떤 노드가 고장을 일으킨다면 파드는 유실되며, 쿠버네티스는 유실된 파드를 새 파드로 대체하지 않는다
- -> 여러 파드를 실행하며, 고가용성을 확보하려고 해도 모든 파드가 다른 노드에 흩어져서 실행된다는 보장이 없다
- -> 억지로 서로 다른 노드에 실행되도록 사람이 직접 관리해야 한다면, 오케스트레이션 도구를 사용하는 의미가 없다

- 컨트롤러 객체가 바로 이런 불편함을 해결해준다
- -> 컨트롤러 객체는 다른 리소스를 관리하는 쿠버네티스 리소스다
- -> 컨트롤러는 쿠버네티스 API와 연동하며, 시스템의 현재 상태를 감시하다가 '바람직한 상태'와 차이가 생기면
-    필요에 따라, 그 차이를 바로 잡는다
- -> 쿠버네티스에는 여러가지 컨트롤러 객체가 있다
- -> 그중에서도 파드를 주로 관리하는 컨트롤러 객체는 디플로이먼트다
- -> 앞서 설명했던 파드의 문제점을 디플로이먼트가 모두 해결해준다
- -> 어떤 노드가 고장을 일으켜 파드가 유실되면, 디플로이먼트가 대체 파드를 다른 노드에 실행한다.
- -> 디플로이먼트를 스케일링 하고 싶다면, 필요한 파드 수를 지정하면 된다.

- - 그러면 디플로이먼트가 여러 노드에 걸쳐 필요한 수만큼 파드를 실행한다
  -> 그림 2-6은 디플로이먼트와 파드, 컨테이너의 관계를 나타낸 다이어그램이다.

- kubectl을 사용하여 컨테이너를 실행할 이미지와 파드 설정을 지정하면 디플로이먼트를 생성할 수 있다
-> 쿠버네티스가 디플로이먼트를 생성하면 디플로이먼트가 파드를 생성한다

-필자의 환경에서 실행한 결과를 그림 2-7에 실었다
-> 이제 클러스터에는 파드 두 개가 생겼다
-> 첫번째는 앞서 kubectl이 run 명령을 사용해서 만든 것이고, 두 번째는 디플로이먼트가 생성했다
-> 디플로이먼트가 생성한 파드 이름은 쿠버네티스가 지은 것으로, 디플로이먼트 이름 뒤에 무작위 문자열이 붙은 형태다. 

